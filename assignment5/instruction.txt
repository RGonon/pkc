1) generate_prime_subgroup(plen, qlen = 160): it takes prime bit lengths for p 
and q and return two primes p, q, and a generator g such that p = kq+1 for 
some random integer k. Note that the default bit length of the prime q is 160.
To find a prime p, it first find a prime q and then sets p = kq+1 for random k 
and then check whether p is prime or not. If it is not prime, it performs 
the previous step by using different k until it finds a prime p. To find a 
generator g, it first select a random integer a such that 1 < a < p and 
returns g = a^k mod p.

2) schnorr_setup(plen): it takes a prime bit length and return parameter pp 
that contains (p, q, g) by using generate_prime_subgroup with qlen = 160.

3) schnorr_genkey(pp): it takes a parameter pp and returns a private key sk 
and a public key pk. Note that the private key sk randomly selected from 0 to q-1.

4) schnorr_hash(R, msg, q): it takes an integer R which is the first component 
of signature, a message string msg, and a prime q in pp, and then it output 
a (integer) hash value h which is computed as h = H(R || m) mod q. To compute 
hash, you can use the hashlib module of python. Be caseful of converting a 
string value to an integer value.

5) schnorr_sign(msg, sk, pp): it takes a message string msg with a private 
key sk and returns a signature sig.

6) schnorr_verify(sig, msg, pk, pp): it outputs 1 if the signature is valid or 0 otherwise.
The report should contain the results of the following examples for each plen = 256, 512, 1024, and 2048:
>> plen = 512
>> pp = schnorr_setup(plen)
>> sk, pk = schnorr_genkey(pp) 
>> msg = 'This is a text message'
>> sig = schnorr_sign(msg, sk, pp)
>> schnorr_verify(sig, m, pk, pp)
